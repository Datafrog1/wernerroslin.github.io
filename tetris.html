<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-LRLHN7K86D"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-LRLHN7K86D');
    </script>
    
    <title>Tetris Game</title>
    
    <!-- Favicon and App Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
    <link rel="manifest" href="/assets/icons/site.webmanifest">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #1a1a2e 100%);
            background-size: 400% 400%;
            animation: darkGradientShift 20s ease infinite;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            margin: 0;
            overflow-x: hidden;
        }

        @keyframes darkGradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .game-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 25px;
            border-radius: 25px;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            max-width: 100vw;
            align-items: center;
            position: relative;
        }

        .game-container::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3);
            background-size: 400% 400%;
            animation: borderGlow 8s ease infinite;
            border-radius: 27px;
            z-index: -1;
            opacity: 0.8;
        }

        @keyframes borderGlow {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .controls {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 20px;
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: pointer;
            overflow: hidden;
            order: 1;
            width: 100%;
            max-width: 450px;
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .controls::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .controls:hover::before {
            left: 100%;
        }

        .controls:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.08) 100%);
            border-color: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        .info-panels-row {
            display: flex;
            gap: 12px;  /* 20px ‚Üí 12px */
            order: 2;
            width: 100%;
            max-width: 200px;  /* 520px ‚Üí 200px */
            justify-content: center;
        }

        .info-panel {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 6px;  /* 8px ‚Üí 6px */
            border-radius: 10px;  /* 12px ‚Üí 10px */
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);  /* Pienempi varjo */
            transition: all 0.3s ease;
            max-width: 90px;  /* 120px ‚Üí 90px */
            min-height: 65px;  /* 80px ‚Üí 65px */
        }

        .info-panel h2 {
            text-align: center;
            margin-bottom: 4px;  /* 6px ‚Üí 4px */
            color: #ffffff;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.3);
            font-size: 10px;  /* 12px ‚Üí 10px */
            font-weight: bold;
            letter-spacing: 0.5px;  /* 1px ‚Üí 0.5px */
            position: relative;
            z-index: 1;
        }

        .score-display {
            font-size: 14px;  /* 18px ‚Üí 14px */
            font-weight: bold;
            text-align: center;
            color: #00ff88;
            text-shadow: 
                0 0 6px rgba(0, 255, 136, 0.8),  /* 8px ‚Üí 6px */
                0 0 12px rgba(0, 255, 136, 0.4),  /* 16px ‚Üí 12px */
                0 0 18px rgba(0, 255, 136, 0.2);  /* 24px ‚Üí 18px */
            position: relative;
            z-index: 1;
        }

        .level-display {
            font-size: 9px;  /* 12px ‚Üí 9px */
            text-align: center;
            margin-top: 3px;  /* 4px ‚Üí 3px */
            color: #ff6b6b;
            text-shadow: 0 0 6px rgba(255, 107, 107, 0.6);  /* 8px ‚Üí 6px */
            position: relative;
            z-index: 1;
        }

        .lines-display {
            font-size: 8px;  /* 10px ‚Üí 8px */
            text-align: center;
            margin-top: 2px;  /* 3px ‚Üí 2px */
            color: #4ecdc4;
            text-shadow: 0 0 6px rgba(78, 205, 196, 0.6);  /* 8px ‚Üí 6px */
            position: relative;
            z-index: 1;
        }

        .next-piece {
            width: 50px;  /* 70px ‚Üí 50px */
            height: 50px;  /* 70px ‚Üí 50px */
            background: linear-gradient(135deg, #000 0%, #1a1a2e 50%, #16213e 100%);
            border: 1px solid rgba(255, 255, 255, 0.3);  /* 2px ‚Üí 1px */
            border-radius: 6px;  /* 8px ‚Üí 6px */
            display: block;
            image-rendering: pixelated;
            box-shadow: 
                inset 0 0 10px rgba(0, 150, 255, 0.2),  /* 15px ‚Üí 10px */
                0 0 8px rgba(0, 0, 0, 0.3);  /* 10px ‚Üí 8px */
            position: relative;
            z-index: 1;
        }

        #tetris {
            display: block;
            background: linear-gradient(135deg, #0f1419 0%, #1a1a2e 50%, #16213e 100%);
            border: 3px solid rgba(0, 255, 255, 0.8);
            box-shadow: 
                inset 0 0 30px rgba(0, 150, 255, 0.3),
                0 0 30px rgba(0, 255, 255, 0.5),
                0 0 60px rgba(0, 255, 255, 0.2);
            width: 320px;
            height: 640px;
            border-radius: 15px;
            touch-action: none;
            user-select: none;
            order: 3;
            position: relative;
            transition: all 0.3s ease;
        }

        #tetris:hover {
            box-shadow: 
                inset 0 0 30px rgba(0, 150, 255, 0.4),
                0 0 40px rgba(0, 255, 255, 0.7),
                0 0 80px rgba(0, 255, 255, 0.3);
            transform: scale(1.01);
        }

        .controls h3 {
            color: #ffffff;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 1px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
        }

        .controls-content {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: all 0.4s ease;
            position: relative;
            z-index: 1;
        }

        .controls.expanded .controls-content {
            max-height: 500px;
            opacity: 1;
            margin-top: 15px;
        }

        .controls.expanded {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.18) 0%, rgba(255, 255, 255, 0.1) 100%);
            border-color: rgba(255, 255, 255, 0.25);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.2);
        }

        .controls h3::after {
            content: " ‚ñº";
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            transition: transform 0.3s ease;
        }

        .controls.expanded h3::after {
            transform: rotate(180deg);
        }

        .controls p {
            margin: 8px 0;
            font-size: 14px;
            color: #ffffff;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        .pause-btn {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .pause-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }

        .pause-btn:hover::before {
            animation: shine 0.5s ease-in-out;
        }

        @keyframes shine {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); opacity: 0; }
        }

        .pause-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.4);
        }

        .new-game-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
            position: relative;
            overflow: hidden;
        }

        .new-game-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: all 0.5s;
            opacity: 0;
        }

        .new-game-btn:hover::before {
            animation: shine 0.5s ease-in-out;
        }

        .new-game-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
            background: linear-gradient(45deg, #ff5252, #e53935);
        }

        .volume-control {
            margin-top: 15px;
        }

        .volume-slider {
            height: 6px;
            margin-top: 8px;
            width: 100%;
            accent-color: #ffd700;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .volume-label {
            font-size: 14px;
            color: #ffffff;
            margin-bottom: 5px;
            display: block;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        #volumeValue {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        .back-button-container {
            position: fixed;
            top: 8px;
            left: 8px;  /* Muutettu: 50% ‚Üí 8px */
            transform: none;  /* Muutettu: translateX(-50%) ‚Üí none */
            z-index: 100;
        }

        .back-btn {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(15px);
            color: #ffffff;
            text-decoration: none;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        .back-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.1) 100%);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(30, 30, 60, 0.95) 100%);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 71, 87, 0.8);
            color: white;
            padding: 40px;
            border-radius: 25px;
            text-align: center;
            display: none;
            z-index: 1000;
            max-width: 90vw;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        }

        .game-over h2 {
            color: #ff4757;
            margin-bottom: 20px;
            font-size: 32px;
            text-shadow: 
                0 0 10px rgba(255, 71, 87, 0.8),
                0 0 20px rgba(255, 71, 87, 0.4);
        }

        .restart-btn {
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 210, 255, 0.3);
            font-weight: bold;
        }

        .restart-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 210, 255, 0.4);
        }

        /* Parempien animaatioiden lis√§ys */
        @keyframes lineComplete {
            0% { background-color: #fff; box-shadow: 0 0 20px #fff; }
            50% { background-color: #ff0000; box-shadow: 0 0 30px #ff0000; }
            100% { background-color: #fff; box-shadow: 0 0 20px #fff; }
        }

        .line-flash {
            animation: lineComplete 0.3s ease-in-out 3;
        }

        @keyframes levelUp {
            0% { 
                transform: scale(1);
                color: #ff6b6b;
                text-shadow: 0 0 10px rgba(255, 107, 107, 0.6);
            }
            50% { 
                transform: scale(1.3);
                color: #ffd700;
                text-shadow: 
                    0 0 20px rgba(255, 215, 0, 1),
                    0 0 40px rgba(255, 215, 0, 0.5);
            }
            100% { 
                transform: scale(1);
                color: #ff6b6b;
                text-shadow: 0 0 10px rgba(255, 107, 107, 0.6);
            }
        }

        .level-up-animation {
            animation: levelUp 0.8s ease-in-out;
        }

        /* SAFE AREA MOBILE LAYOUT - Bottom navigation support */
        @media (max-width: 768px) {
            body {
                padding: 1px;
                padding-top: max(25px, env(safe-area-inset-top));
                padding-bottom: max(10px, env(safe-area-inset-bottom)); /* UUSI: Bottom safe area */
                min-height: 100vh;
                min-height: 100dvh; /* UUSI: Dynamic viewport height */
                overflow: hidden;
            }
            
            .game-container {
                gap: 3px;
                padding: 4px;
                border-radius: 8px;
                width: calc(100vw - 2px);
                max-width: calc(100vw - 2px);
                min-height: calc(100dvh - max(26px, env(safe-area-inset-top)) - max(10px, env(safe-area-inset-bottom)));
                justify-content: space-between;
                display: flex;
                flex-direction: column;
            }
            
            .controls {
                order: 1;
                padding: 3px;
                font-size: 8px;
                border-radius: 6px;
                width: 100%;
                flex-shrink: 0;
                max-height: 22px;
                overflow: hidden;
            }
            
            .controls h3 {
                font-size: 9px;
                margin-bottom: 2px;
            }
            
            .controls.expanded {
                max-height: 120px;
            }
            
            .info-panels-row {
                gap: 3px;
                width: 100%;
                order: 2;
                flex-shrink: 0;
                max-height: 40px;
            }
            
            .info-panel {
                padding: 2px;
                border-radius: 4px;
                min-height: 35px;
                max-height: 35px;
                max-width: 60px;
            }
            
            .info-panel h2 {
                font-size: 7px;
                margin-bottom: 1px;
            }
            
            .score-display {
                font-size: 10px;
            }
            
            .level-display {
                font-size: 6px;
                margin-top: 1px;
            }
            
            .lines-display {
                font-size: 5px;
                margin-top: 0px;
            }
            
            .next-piece {
                width: 30px;
                height: 30px;
                border-radius: 3px;
            }
            
            #tetris {
                order: 3;
                flex: 1;
                width: 100% !important;
                height: auto !important;
                min-height: 0;
                border-radius: 6px;
                border-width: 1px;
                max-height: calc(100dvh - max(26px, env(safe-area-inset-top)) - max(10px, env(safe-area-inset-bottom)) - 40px - 22px - 12px);
                margin-bottom: max(5px, env(safe-area-inset-bottom)); /* UUSI: Extra margin bottom */
            }
            
            .controls p {
                font-size: 6px;
                margin: 1px 0;
            }
            
            .pause-btn, .new-game-btn {
                padding: 2px 4px;
                font-size: 6px;
                margin-top: 1px;
                border-radius: 4px;
            }
            
            .back-btn {
                padding: 3px 6px;
                font-size: 8px;
                border-radius: 4px;
                top: max(2px, env(safe-area-inset-top));
                left: max(2px, env(safe-area-inset-left));
            }
            
            .volume-control {
                margin-top: 2px;
            }
            
            .volume-slider {
                height: 1px;
                margin-top: 1px;
            }
            
            .volume-label {
                font-size: 6px;
                margin-bottom: 1px;
            }
            
            #volumeValue {
                font-size: 5px;
            }
        }

        /* EXTRA SMALL - iPhone SE with safe areas */
        @media (max-width: 350px) {
            body {
                padding: 0px;
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(8px, env(safe-area-inset-bottom)); /* UUSI */
                min-height: 100dvh; /* UUSI */
            }
            
            .game-container {
                gap: 2px;
                padding: 3px;
                min-height: calc(100dvh - max(20px, env(safe-area-inset-top)) - max(8px, env(safe-area-inset-bottom)));
                width: 100vw;
                max-width: 100vw;
            }
            
            .controls {
                padding: 2px;
                font-size: 7px;
                max-height: 18px;
            }
            
            .controls h3 {
                font-size: 8px;
                margin-bottom: 1px;
            }
            
            .info-panels-row {
                gap: 2px;
                max-height: 32px;
            }
            
            .info-panel {
                padding: 1px;
                min-height: 28px;
                max-height: 28px;
                max-width: 50px;
            }
            
            .info-panel h2 {
                font-size: 6px;
            }
            
            .score-display {
                font-size: 8px;
            }
            
            .level-display {
                font-size: 5px;
            }
            
            .lines-display {
                font-size: 4px;
            }
            
            .next-piece {
                width: 24px;
                height: 24px;
            }
            
            #tetris {
                max-height: calc(100dvh - max(20px, env(safe-area-inset-top)) - max(8px, env(safe-area-inset-bottom)) - 32px - 18px - 8px);
                margin-bottom: max(3px, env(safe-area-inset-bottom)); /* UUSI */
            }
            
            .controls p {
                font-size: 5px;
                margin: 0px;
            }
            
            .pause-btn, .new-game-btn {
                padding: 1px 3px;
                font-size: 5px;
                margin-top: 1px;
            }
            
            .back-btn {
                padding: 2px 4px;
                font-size: 7px;
                top: max(1px, env(safe-area-inset-top));
                left: max(1px, env(safe-area-inset-left));
            }
        }

        /* MICRO - with safe areas */
        @media (max-width: 300px) {
            .info-panel {
                max-width: 40px;
                min-height: 24px;
                max-height: 24px;
            }
            
            .info-panel h2 {
                font-size: 5px;
            }
            
            .score-display {
                font-size: 7px;
            }
            
            .level-display {
                font-size: 4px;
            }
            
            .lines-display {
                font-size: 3px;
            }
            
            .next-piece {
                width: 20px;
                height: 20px;
            }
            
            .info-panels-row {
                max-height: 28px;
            }
            
            #tetris {
                margin-bottom: max(2px, env(safe-area-inset-bottom)); /* UUSI */
            }
        }

        /* Landscape with bottom navigation */
        @media (max-height: 500px) and (orientation: landscape) and (max-width: 900px) {
            body {
                padding: 1px;
                padding-top: max(20px, env(safe-area-inset-top));
                padding-bottom: max(5px, env(safe-area-inset-bottom)); /* UUSI */
                padding-left: env(safe-area-inset-left);
                padding-right: env(safe-area-inset-right);
            }
            
            .game-container {
                flex-direction: row;
                gap: 4px;
                padding: 4px;
                min-height: calc(100vh - max(21px, env(safe-area-inset-top)) - max(5px, env(safe-area-inset-bottom)));
                align-items: stretch;
                width: calc(100vw - env(safe-area-inset-left) - env(safe-area-inset-right) - 2px);
                max-width: calc(100vw - env(safe-area-inset-left) - env(safe-area-inset-right) - 2px);
            }
            
            .controls {
                order: 1;
                width: 120px;
                flex-shrink: 0;
                max-height: none;
                font-size: 8px;
                padding: 4px;
            }
            
            .controls h3 {
                font-size: 9px;
                margin-bottom: 3px;
            }
            
            .info-panels-row {
                order: 3;
                flex-direction: column;
                width: 80px;
                flex-shrink: 0;
                max-height: none;
                gap: 3px;
            }
            
            .info-panel {
                min-height: 60px;
                max-height: none;
                padding: 4px;
            }
            
            .info-panel h2 {
                font-size: 8px;
            }
            
            .score-display {
                font-size: 10px;
            }
            
            .next-piece {
                width: 35px;
                height: 35px;
            }
            
            #tetris {
                order: 2;
                flex: 1;
                height: auto !important;
                width: auto !important;
                min-width: 0;
                max-height: calc(100vh - max(21px, env(safe-area-inset-top)) - max(5px, env(safe-area-inset-bottom)) - 8px);
            }
            
            .controls p {
                font-size: 7px;
            }
            
            .pause-btn, .new-game-btn {
                font-size: 7px;
                padding: 3px 5px;
            }
            
            .back-btn {
                top: max(2px, env(safe-area-inset-top));
                left: max(2px, env(safe-area-inset-left));
            }
        }
    </style>
</head>
<body>
    <!-- Takaisin-nappi -->
    <div class="back-button-container">
        <a href="index.html" class="back-btn">
            ‚¨ÖÔ∏è Back to Home
        </a>
    </div>

    <div class="game-container">
        <!-- 1. SCORE ja NEXT yl√∂s -->
        <div class="info-panels-row">
            <div class="info-panel">
                <h2>SCORE</h2>
                <div class="score-display" id="score">0</div>
                <div class="level-display">Level: <span id="level">1</span></div>
                <div class="lines-display">Lines: <span id="lines">0</span></div>
            </div>

            <div class="info-panel">
                <h2>NEXT</h2>
                <canvas class="next-piece" id="nextPiece" width="120" height="120"></canvas>
            </div>
        </div>

        <!-- 2. TETRIS keskelle - POISTA .game-board wrapper! -->
        <canvas id="tetris" width="300" height="600"></canvas>
        
        <!-- 3. CONTROLS alas -->
        <div class="controls" id="controlsPanel">
            <h3>CONTROLS</h3>
            <div class="controls-content">
                <p>‚¨ÖÔ∏è A / ‚Üê - Left</p>
                <p>‚û°Ô∏è D / ‚Üí - Right</p>
                <p>‚¨áÔ∏è S / ‚Üì - Down</p>
                <p>üîÑ W / ‚Üë - Rotate</p>
                <p>‚ö° Space - Drop</p>
                <p>‚è∏Ô∏è P - Pause</p>
                <p>üîÑ Ctrl+R - New Game</p>
                <button class="pause-btn" id="pauseBtn">‚è∏Ô∏è PAUSE</button>
                <button class="new-game-btn" id="newGameBtn">üéÆ NEW GAME</button>
                
                <div class="volume-control">
                    <label class="volume-label">üîä Volume</label>
                    <input type="range" class="volume-slider" id="volumeSlider" 
                           min="0" max="100" value="50">
                    <span id="volumeValue">50%</span>
                </div>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>GAME OVER!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Level: <span id="finalLevel">1</span></p>
        <p>Lines: <span id="finalLines">0</span></p>
        <button class="restart-btn" onclick="startNewGame()">üéÆ NEW GAME</button>
    </div>

    <script>
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('nextPiece');
const nextContext = nextCanvas.getContext('2d');

// Pelin muuttujat
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
let score = 0;
let level = 1;
let lines = 0;
let isPaused = false;
let gameOver = false;
let soundVolume = 0.5;

// Touch/Mouse muuttujat
let isDragging = false;
let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;

// Tetris-palikat
const tetrominoes = {
    T: [
        [0, 1, 0],
        [1, 1, 1],
        [0, 0, 0]
    ],
    O: [
        [1, 1],
        [1, 1]
    ],
    L: [
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 0]
    ],
    J: [
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ],
    I: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ],
    S: [
        [0, 1, 1],
        [1, 1, 0],
        [0, 0, 0]
    ],
    Z: [
        [1, 1, 0],
        [0, 1, 1],
        [0, 0, 0]
    ]
};

// V√§rit
const colors = {
    T: '#a855f7',
    O: '#fbbf24',
    L: '#f97316',
    J: '#3b82f6',
    I: '#06b6d4',
    S: '#10b981',
    Z: '#ef4444'
};

// Pelialue
const arena = createMatrix(10, 20);

// Pelaajan pala
const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    type: null
};

let nextPiece = null;

// √Ñ√ÑNITEHOSTEET - KORJATTU VERSIO
let audioContext = null;
let audioInitialized = false;

function initAudio() {
    if (audioContext || soundVolume === 0) return;
    
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioInitialized = true;
        console.log('Audio initialized successfully');
    } catch (e) {
        console.log('Audio not supported:', e);
        audioInitialized = false;
    }
}

function resumeAudioContext() {
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
            console.log('Audio context resumed');
        }).catch(e => {
            console.log('Failed to resume audio context:', e);
        });
    }
}

function createBeep(frequency, duration, type = 'sine') {
    if (soundVolume === 0) return;
    
    // Alusta audio ensimm√§isell√§ kerralla
    if (!audioContext) {
        initAudio();
    }
    
    if (!audioContext || !audioInitialized) return;
    
    try {
        // Varmista ett√§ context on k√§ynniss√§
        resumeAudioContext();
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        oscillator.type = type;
        
        // Lyhyempi fade out, v√§hemm√§n eksponentiaalinen
        const volume = soundVolume * 0.1;
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
        
        // Siivoa muisti
        oscillator.onended = () => {
            try {
                oscillator.disconnect();
                gainNode.disconnect();
            } catch (e) {
                // Ei tee mit√§√§n jos jo disconnected
            }
        };
        
    } catch (e) {
        console.log('Audio creation failed:', e);
        // Yrit√§ alustaa uudelleen seuraavalla kerralla
        audioContext = null;
        audioInitialized = false;
    }
}

// √Ñ√§ni-funktiot pysyv√§t samoina
function playRotateSound() {
    createBeep(300, 0.15, 'sine');
}

function playMoveSound() {
    createBeep(200, 0.1, 'sine');
}

function playDropSound() {
    createBeep(120, 0.2, 'sine');
}

function playLineSound() {
    setTimeout(() => createBeep(262, 0.15, 'sine'), 0);
    setTimeout(() => createBeep(330, 0.15, 'sine'), 150);
    setTimeout(() => createBeep(392, 0.15, 'sine'), 300);
    setTimeout(() => createBeep(523, 0.25, 'sine'), 450);
}

function playTetrisSound() {
    setTimeout(() => createBeep(262, 0.12, 'sine'), 0);
    setTimeout(() => createBeep(330, 0.12, 'sine'), 120);
    setTimeout(() => createBeep(392, 0.12, 'sine'), 240);
    setTimeout(() => createBeep(523, 0.12, 'sine'), 360);
    setTimeout(() => createBeep(659, 0.12, 'sine'), 480);
    setTimeout(() => createBeep(784, 0.25, 'sine'), 600);
}

function playGameOverSound() {
    setTimeout(() => createBeep(392, 0.3, 'sine'), 0);
    setTimeout(() => createBeep(370, 0.3, 'sine'), 300);
    setTimeout(() => createBeep(349, 0.3, 'sine'), 600);
    setTimeout(() => createBeep(330, 0.3, 'sine'), 900);
    setTimeout(() => createBeep(294, 0.3, 'sine'), 1200);
    setTimeout(() => createBeep(262, 0.5, 'sine'), 1500);
}

function playLevelUpSound() {
    setTimeout(() => createBeep(262, 0.15, 'sine'), 0);
    setTimeout(() => createBeep(294, 0.15, 'sine'), 150);
    setTimeout(() => createBeep(330, 0.15, 'sine'), 300);
    setTimeout(() => createBeep(349, 0.15, 'sine'), 450);
    setTimeout(() => createBeep(392, 0.25, 'sine'), 600);
}

function createMatrix(w, h) {
    const matrix = [];
    while (h--) {
        matrix.push(new Array(w).fill(0));
    }
    return matrix;
}

function createPiece(type) {
    return tetrominoes[type];
}

function drawGrid() {
    // M√§√§rit√§ ruudukon koko dynaamisesti
    const gridWidth = canvas.width / context.getTransform().a; // a = scaleX
    const gridHeight = canvas.height / context.getTransform().d; // d = scaleY
    
    // Ohut ristikko
    context.strokeStyle = 'rgba(0, 100, 150, 0.4)';
    context.lineWidth = 0.02;
    
    // Pystyviivat
    for (let x = 0; x <= 10; x++) {
        context.beginPath();
        context.moveTo(x, 0);
        context.lineTo(x, 20);
        context.stroke();
    }
    
    // Vaakaviivat
    for (let y = 0; y <= 20; y++) {
        context.beginPath();
        context.moveTo(0, y);
        context.lineTo(10, y);
        context.stroke();
    }
    
    // Paksummat 5-ruudun viivat
    context.strokeStyle = 'rgba(0, 150, 255, 0.6)';
    context.lineWidth = 0.03;
    
    for (let y = 5; y <= 20; y += 5) {
        context.beginPath();
        context.moveTo(0, y);
        context.lineTo(10, y);
        context.stroke();
    }
    
    // Vaara-alue (alaosa)
    context.fillStyle = 'rgba(255, 0, 0, 0.05)';
    context.fillRect(0, 17, 10, 3);
}

function draw() {
    // M√§√§rit√§ canvas koko dynaamisesti
    const canvasWidth = canvas.width / context.getTransform().a;
    const canvasHeight = canvas.height / context.getTransform().d;
    
    if (gameOver && !player.matrix) {
        context.fillStyle = '#000';
        context.fillRect(0, 0, canvasWidth, canvasHeight);
        drawGrid();

        arena.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    context.fillStyle = value;
                    context.fillRect(x, y, 1, 1);
                    
                    context.strokeStyle = '#fff';
                    context.lineWidth = 0.05;
                    context.strokeRect(x, y, 1, 1);
                }
            });
        });
        return;
    }

    context.fillStyle = '#000';
    context.fillRect(0, 0, canvasWidth, canvasHeight);

    drawGrid();

    // Piirr√§ arena (kiinte√§t palikat)
    arena.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                context.fillStyle = value;
                context.fillRect(x, y, 1, 1);
                
                context.strokeStyle = '#fff';
                context.lineWidth = 0.05;
                context.strokeRect(x, y, 1, 1);
            }
        });
    });

    // Piirr√§ ghost piece ENNEN nykyist√§ palaa
    if (player.matrix && !gameOver) {
        drawGhostPiece();
    }

    // Piirr√§ nykyinen pala (p√§√§llimm√§iseksi)
    if (player.matrix && !gameOver) {
        player.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    const drawY = y + player.pos.y;
                    const drawX = x + player.pos.x;
                    
                    if (drawY >= 0 && drawY < 20 && drawX >= 0 && drawX < 10) {
                        context.fillStyle = colors[player.type];
                        context.fillRect(drawX, drawY, 1, 1);
                        
                        context.strokeStyle = '#fff';
                        context.lineWidth = 0.05;
                        context.strokeRect(drawX, drawY, 1, 1);
                    }
                }
            });
        });
    }

    if (!gameOver) {
        drawNextPiece();
    } else {
        // Tyhjenn√§ next canvas game over -tilassa
        const nextCanvasSize = nextCanvas.width / nextContext.getTransform().a;
        nextContext.fillStyle = '#000';
        nextContext.fillRect(0, 0, nextCanvasSize, nextCanvasSize);
    }
}

function drawNextPiece() {
    if (!nextPiece) return;
    
    // Tyhjenn√§ next canvas
    const nextCanvasSize = nextCanvas.width / nextContext.getTransform().a;
    nextContext.fillStyle = '#000';
    nextContext.fillRect(0, 0, nextCanvasSize, nextCanvasSize);
    
    // Piirr√§ next piece keskelle
    const matrix = nextPiece.matrix;
    const color = colors[nextPiece.type];
    
    // Laske keskitys
    const pieceWidth = matrix[0].length;
    const pieceHeight = matrix.length;
    const startX = Math.floor((6 - pieceWidth) / 2); // 6x6 ruudukko
    const startY = Math.floor((6 - pieceHeight) / 2);
    
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                const drawX = startX + x;
                const drawY = startY + y;
                
                // Piirr√§ pala
                nextContext.fillStyle = color;
                nextContext.fillRect(drawX, drawY, 1, 1);
                
                // Piirr√§ reunus
                nextContext.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                nextContext.lineWidth = 0.05;
                nextContext.strokeRect(drawX, drawY, 1, 1);
            }
        });
    });
}

function drawGhostPiece() {
    if (!player.matrix || gameOver) return;
    
    // Etsi ghost-paikan Y-koordinaatti
    let ghostY = player.pos.y;
    const originalY = player.pos.y;
    
    // Liikuta palaa alasp√§in kunnes se t√∂rm√§√§
    player.pos.y = ghostY;
    while (!collide(arena, player)) {
        ghostY++;
        player.pos.y = ghostY;
    }
    ghostY--; // Yksi askel takaisin (viimeinen validi paikka)
    
    // Palauta alkuper√§inen Y-koordinaatti
    player.pos.y = originalY;
    
    // Jos ghost ja nykyinen pala ovat samassa paikassa, √§l√§ piirr√§
    if (ghostY <= player.pos.y) return;
    
    // Piirr√§ ghost piece l√§pin√§kyv√§n√§
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                const drawY = y + ghostY;
                const drawX = x + player.pos.x;
                
                if (drawY >= 0 && drawY < 20 && drawX >= 0 && drawX < 10) {
                    // L√§pin√§kyv√§ ghost-versio palan v√§rist√§
                    const ghostColor = colors[player.type];
                    
                    // Muunna hex-v√§ri rgba:ksi l√§pin√§kyvyydell√§
                    let r, g, b;
                    if (ghostColor.startsWith('#')) {
                        const hex = ghostColor.slice(1);
                        r = parseInt(hex.slice(0, 2), 16);
                        g = parseInt(hex.slice(2, 4), 16);
                        b = parseInt(hex.slice(4, 6), 16);
                    } else {
                        // Jos v√§ri on jo RGB-muodossa, k√§yt√§ oletusarvoja
                        r = 200; g = 200; b = 200;
                    }
                    
                    // Piirr√§ l√§pin√§kyv√§ t√§ytt√∂
                    context.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                    context.fillRect(drawX, drawY, 1, 1);
                    
                    // Piirr√§ katkoviiva-reunus
                    context.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                    context.lineWidth = 0.08;
                    context.setLineDash([0.1, 0.1]); // Katkoviiva
                    context.strokeRect(drawX, drawY, 1, 1);
                    context.setLineDash([]); // Takaisin yhten√§iseen viivaan
                }
            }
        });
    });
}

function merge(arena, player) {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                const mergeY = y + player.pos.y;
                const mergeX = x + player.pos.x;
                
                // Tarkista ett√§ koordinaatit ovat alueen sis√§ll√§
                if (mergeY >= 0 && mergeY < arena.length && 
                    mergeX >= 0 && mergeX < arena[0].length) {
                    arena[mergeY][mergeX] = colors[player.type];
                }
            }
        });
    });
}

function rotate(matrix, dir = 1) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }

    if (dir > 0) {
        matrix.forEach(row => row.reverse());
    } else {
        matrix.reverse();
    }
}

function collide(arena, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0) {
                if (y + o.y >= 0) {
                    if (y + o.y >= arena.length || 
                        x + o.x < 0 || 
                        x + o.x >= arena[0].length || 
                        arena[y + o.y][x + o.x] !== 0) {
                    return true;
                }
                } else {
                    if (x + o.x < 0 || x + o.x >= arena[0].length) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

function arenaSweep() {
    let linesCleared = 0;
    
    for (let y = arena.length - 1; y >= 0; --y) {
        let fullLine = true;
        
        for (let x = 0; x < arena[y].length; ++x) {
            if (arena[y][x] === 0) {
                fullLine = false;
                break;
            }
        }
        
        if (fullLine) {
            arena.splice(y, 1);
            arena.unshift(new Array(10).fill(0));
            linesCleared++;
            y++;
        }
    }

    if (linesCleared > 0) {
        if (linesCleared === 4) {
            playTetrisSound();
        } else {
            playLineSound();
        }

        const pointValues = [0, 40, 100, 300, 1200];
        const oldLevel = level;
        score += pointValues[linesCleared] * level;
        lines += linesCleared;
        
        level = Math.floor(lines / 10) + 1;
        
        if (level > oldLevel) {
            setTimeout(() => {
                playLevelUpSound();
                const levelElement = document.getElementById('level').parentElement;
                levelElement.classList.add('level-up-animation');
                setTimeout(() => {
                    levelElement.classList.remove('level-up-animation');
                }, 600);
            }, 500);
        }
        
        dropInterval = Math.max(50, 1000 - (level - 1) * 50);
        updateDisplay();
    }
}

function playerDrop() {
    if (gameOver) return;
    
    player.pos.y++;
    if (collide(arena, player)) {
        player.pos.y--;
        playDropSound();
        merge(arena, player);
        playerReset();
        arenaSweep();
    }
    dropCounter = 0;
}

function playerMove(dir) {
    if (gameOver) return;
    
    player.pos.x += dir;
    if (collide(arena, player)) {
        player.pos.x -= dir;
    } else {
        playMoveSound();
    }
}

function playerReset() {
    if (gameOver) return;
    
    if (nextPiece) {
        player.matrix = JSON.parse(JSON.stringify(nextPiece.matrix));
        player.type = nextPiece.type;
    } else {
        const pieces = 'TLOJISZ';
        const type = pieces[Math.floor(Math.random() * pieces.length)];
        player.matrix = JSON.parse(JSON.stringify(createPiece(type)));
        player.type = type;
    }
    
    const pieces = 'TLOJISZ';
    const nextType = pieces[Math.floor(Math.random() * pieces.length)];
    nextPiece = {
        matrix: JSON.parse(JSON.stringify(createPiece(nextType))),
        type: nextType
    };

    player.pos.y = -1;
    player.pos.x = Math.floor((arena[0].length - player.matrix[0].length) / 2);
    
    if (collide(arena, player)) {
        endGame();
        return;
    }
}

function playerRotate(dir) {
    if (gameOver) return;
    
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
            rotate(player.matrix, -dir);
            player.pos.x = pos;
            return;
        }
    }
    playRotateSound();
}

function hardDrop() {
    if (gameOver) return;
    
    while (!collide(arena, player)) {
        player.pos.y++;
        score += 1;
    }
    player.pos.y--;
    createBeep(100, 0.3, 'sine');
    merge(arena, player);
    playerReset();
    arenaSweep();
    updateDisplay();
}

function updateDisplay() {
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = lines;
}

function endGame() {
    // Analytics
    if (typeof gtag !== 'undefined') {
        gtag('event', 'game_over', { 
            event_category: 'tetris',
            value: score 
        });
    }
    
    gameOver = true;
    playGameOverSound();
    
    player.matrix = null;
    player.type = null;
    
    document.getElementById('finalScore').textContent = score;
    document.getElementById('finalLevel').textContent = level;
    document.getElementById('finalLines').textContent = lines;
    document.getElementById('gameOver').style.display = 'block';
}

function startNewGame() {
    // Analytics
    if (typeof gtag !== 'undefined') {
        gtag('event', 'game_start', { event_category: 'tetris' });
    }
    
    const confirmRestart = gameOver || confirm('Do you really want to start a new game?');
    
    if (!confirmRestart) return;

    gameOver = true;
    
    arena.forEach(row => row.fill(0));
    score = 0;
    level = 1;
    lines = 0;
    dropInterval = 1000;
    dropCounter = 0;
    lastTime = 0;
    isPaused = false;
    
    player.matrix = null;
    player.type = null;
    player.pos = {x: 0, y: 0};
    nextPiece = null;
    
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è PAUSE';
    
    gameOver = false;
    playerReset();
    updateDisplay();
    update();
}

function togglePause() {
    if (gameOver) return;
    
    isPaused = !isPaused;
    const btn = document.getElementById('pauseBtn');
    btn.textContent = isPaused ? '‚ñ∂Ô∏è RESUME' : '‚è∏Ô∏è PAUSE';
}

function update(time = 0) {
    if (gameOver) return;
    
    if (!isPaused) {
        const deltaTime = time - lastTime;
        dropCounter += deltaTime;
        
        if (dropCounter > dropInterval) {
            playerDrop();
        }
    }
    
    lastTime = time;
    draw();
    
    if (!gameOver) {
        requestAnimationFrame(update);
    }
}

// CONTROLS-panelin laajennus
const controlsPanel = document.getElementById('controlsPanel');
let controlsExpanded = false;

controlsPanel.addEventListener('click', (e) => {
    // √Ñl√§ laajenna jos klikkaat nappeja
    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
        return;
    }
    
    controlsExpanded = !controlsExpanded;
    
    if (controlsExpanded) {
        controlsPanel.classList.add('expanded');
    } else {
        controlsPanel.classList.remove('expanded');
    }
});

// Est√§ laajennus/kutistus kun interaktoidaan controlsien kanssa
const controlsContent = document.querySelector('.controls-content');
controlsContent.addEventListener('click', (e) => {
    e.stopPropagation(); // Est√§ klikkauksen kulkeutuminen yl√∂sp√§in
});

// TOUCH & MOUSE KONTROLLIT
function initControls() {
    const canvas = document.getElementById('tetris');
    
    // Touch/Mouse muuttujat toistoa varten
    let touchRepeatInterval = null;
    let touchDirection = null;
    let isLongPress = false;
    
    // CSS hiirelle
    canvas.style.cursor = 'grab';
    canvas.style.transition = 'transform 0.1s ease';
    
    // Alusta audio ensimm√§isen k√§ytt√§j√§vuorovaikutuksen yhteydess√§
    const initAudioOnInteraction = () => {
        if (!audioInitialized) {
            initAudio();
            setTimeout(() => {
                if (soundVolume > 0) {
                    createBeep(200, 0.1, 'sine');
                }
            }, 100);
        }
    };
    
    // Touch events
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        initAudioOnInteraction();
        
        if (gameOver || isPaused) return;
        
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        touchStartX = touch.clientX - rect.left;
        touchStartY = touch.clientY - rect.top;
        touchStartTime = Date.now();
        isLongPress = false;
        
        // Aloita long press timer
        setTimeout(() => {
            if (touchStartTime > 0) { // Viel√§ kosketetaan
                isLongPress = true;
            }
        }, 200);
    }, { passive: false });
    
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (gameOver || isPaused || !isLongPress) return;
        
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const currentX = touch.clientX - rect.left;
        const currentY = touch.clientY - rect.top;
        const deltaX = currentX - touchStartX;
        const deltaY = currentY - touchStartY;
        
        // P√§ivit√§ aloituspiste kun suunta vaihtuu (sujuvampi liike)
        let shouldUpdateStartPos = false;
        
        // M√§√§rit√§ suunta ja aloita/vaihda toisto
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 20) {
            const newDirection = deltaX > 0 ? 'right' : 'left';
            if (touchDirection !== newDirection) {
                touchDirection = newDirection;
                shouldUpdateStartPos = true;
                // Pys√§yt√§ vanha toisto ja aloita uusi
                if (touchRepeatInterval) clearInterval(touchRepeatInterval);
                
                // Tee ensimm√§inen liike heti
                if (touchStartTime > 0 && !gameOver && !isPaused) {
                    playerMove(touchDirection === 'right' ? 1 : -1);
                }
                
                touchRepeatInterval = setInterval(() => {
                    if (touchStartTime > 0 && !gameOver && !isPaused) {
                        playerMove(touchDirection === 'right' ? 1 : -1);
                    }
                }, 100); // 100ms toisto
            }
        } else if (deltaY > 30) {
            if (touchDirection !== 'down') {
                touchDirection = 'down';
                shouldUpdateStartPos = true;
                // Pys√§yt√§ vanha toisto ja aloita uusi
                if (touchRepeatInterval) clearInterval(touchRepeatInterval);
                
                // Tee ensimm√§inen liike heti
                if (touchStartTime > 0 && !gameOver && !isPaused) {
                    playerDrop();
                }
                
                touchRepeatInterval = setInterval(() => {
                    if (touchStartTime > 0 && !gameOver && !isPaused) {
                        playerDrop();
                    }
                }, 80); // 80ms toisto alasp√§in
            }
        }
        
        // P√§ivit√§ aloituspiste sulavampaa liikett√§ varten
        if (shouldUpdateStartPos) {
            touchStartX = currentX;
            touchStartY = currentY;
        }
    }, { passive: false });
    
    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        
        // Pys√§yt√§ toisto
        if (touchRepeatInterval) {
            clearInterval(touchRepeatInterval);
            touchRepeatInterval = null;
        }
        touchDirection = null;
        
        if (gameOver || isPaused) {
            touchStartTime = 0;
            return;
        }
        
        const touchDuration = Date.now() - touchStartTime;
        touchStartTime = 0;
        
        if (!isLongPress) {
            // Lyhyt kosketus - normaalit liikkeet
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            
            const endX = touch.clientX - rect.left;
            const endY = touch.clientY - rect.top;
            const deltaX = endX - touchStartX;
            const deltaY = endY - touchStartY;
            
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                playerMove(deltaX > 0 ? 1 : -1);
            } else if (deltaY > 40) {
                playerDrop();
            } else if (touchDuration < 300 && Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20) {
                playerRotate(1);
            } else if (touchDuration > 600) {
                hardDrop();
            }
        }
    }, { passive: false });
    
    // Mouse events
    canvas.addEventListener('mousedown', (e) => {
        e.preventDefault();
        initAudioOnInteraction();
        
        if (gameOver || isPaused) return;
        
        const rect = canvas.getBoundingClientRect();
        touchStartX = e.clientX - rect.left;
        touchStartY = e.clientY - rect.top;
        touchStartTime = Date.now();
        isDragging = true;
        isLongPress = false;
        canvas.style.cursor = 'grabbing';
        
        // Aloita long press timer hiirelle
        setTimeout(() => {
            if (isDragging && touchStartTime > 0) {
                isLongPress = true;
            }
        }, 200);
    });
    
    canvas.addEventListener('mousemove', (e) => {
        e.preventDefault();
        if (!isDragging || gameOver || isPaused || !isLongPress) return;
        
        const rect = canvas.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        const deltaX = currentX - touchStartX;
        const deltaY = currentY - touchStartY;
        
        // M√§√§rit√§ suunta ja aloita/vaihda toisto hiirelle
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 15) {
            const newDirection = deltaX > 0 ? 'right' : 'left';
            if (touchDirection !== newDirection) {
                touchDirection = newDirection;
                // Pys√§yt√§ vanha toisto ja aloita uusi
                if (touchRepeatInterval) clearInterval(touchRepeatInterval);
                
                // Tee ensimm√§inen liike heti
                if (isDragging && !gameOver && !isPaused) {
                    playerMove(touchDirection === 'right' ? 1 : -1);
                }
                
                touchRepeatInterval = setInterval(() => {
                    if (isDragging && !gameOver && !isPaused) {
                        playerMove(touchDirection === 'right' ? 1 : -1);
                    }
                }, 90); // 90ms toisto hiirelle
            }
        } else if (deltaY > 20) {
            if (touchDirection !== 'down') {
                touchDirection = 'down';
                // Pys√§yt√§ vanha toisto ja aloita uusi
                if (touchRepeatInterval) clearInterval(touchRepeatInterval);
                
                // Tee ensimm√§inen liike heti
                if (isDragging && !gameOver && !isPaused) {
                    playerDrop();
                }
                
                touchRepeatInterval = setInterval(() => {
                    if (isDragging && !gameOver && !isPaused) {
                        playerDrop();
                    }
                }, 70); // 70ms toisto alasp√§in hiirelle
            }
        }
    });
    
    canvas.addEventListener('mouseup', (e) => {
        e.preventDefault();
        
        // Pys√§yt√§ toisto
        if (touchRepeatInterval) {
            clearInterval(touchRepeatInterval);
            touchRepeatInterval = null;
        }
        touchDirection = null;
        
        if (!isDragging) return;
        
        isDragging = false;
        canvas.style.cursor = 'grab';
        
        if (gameOver || isPaused) {
            touchStartTime = 0;
            return;
        }
        
        const mouseDuration = Date.now() - touchStartTime;
        touchStartTime = 0;
        
        if (!isLongPress) {
            // Lyhyt klikkaus - normaalit liikkeet
            const rect = canvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;
            const deltaX = endX - touchStartX;
            const deltaY = endY - touchStartY;
            
            if (e.button === 2) {
                hardDrop();
                return;
            }
            
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 20) {
                playerMove(deltaX > 0 ? 1 : -1);
            } else if (deltaY > 15) {
                playerDrop();
            } else if (mouseDuration < 300 && Math.abs(deltaX) < 15 && Math.abs(deltaY) < 15) {
                playerRotate(1);
            } else if (mouseDuration > 500) {
                hardDrop();
            }
        }
    });
    
    canvas.addEventListener('mouseleave', () => {
        // Pys√§yt√§ toisto kun hiiri poistuu
        if (touchRepeatInterval) {
            clearInterval(touchRepeatInterval);
            touchRepeatInterval = null;
        }
        touchDirection = null;
        isDragging = false;
        isLongPress = false;
        touchStartTime = 0;
        canvas.style.cursor = 'grab';
    });
    
    // Scroll wheel
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (gameOver || isPaused) return;
        
        if (e.deltaY < 0) {
            playerRotate(1);
        } else {
            playerDrop();
        }
    }, { passive: false });
    
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
}

// Keyboard controls
document.addEventListener('keydown', event => {
    // Alusta audio ensimm√§isen n√§pp√§imen painalluksen yhteydess√§
    if (!audioInitialized && soundVolume > 0) {
        initAudio();
    }
    
    if (event.code === 'KeyR' && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        startNewGame();
        return;
    }
    
    if (gameOver) return;
    if (isPaused && event.code !== 'KeyP') return;
    
    switch(event.code) {
        case 'ArrowLeft':
        case 'KeyA':
            event.preventDefault();
            playerMove(-1);
            break;
        case 'ArrowRight':
        case 'KeyD':
            event.preventDefault();
            playerMove(1);
            break;
        case 'ArrowDown':
        case 'KeyS':
            event.preventDefault();
            playerDrop();
            break;
        case 'ArrowUp':
        case 'KeyW':
            event.preventDefault();
            playerRotate(1);
            break;
        case 'Space':
            event.preventDefault();
            hardDrop();
            break;
        case 'KeyP':
            event.preventDefault();
            togglePause();
            break;
    }
});

// Volume control
const volumeSlider = document.getElementById('volumeSlider');
const volumeValue = document.getElementById('volumeValue');

volumeSlider.addEventListener('input', (e) => {
    soundVolume = e.target.value / 100;
    volumeValue.textContent = e.target.value + '%';
});

// Event listeners
document.getElementById('pauseBtn').addEventListener('click', togglePause);
document.getElementById('newGameBtn').addEventListener('click', startNewGame);

// Dynaaminen canvas-skaalaus mobiilille
function adjustCanvasForMobile() {
    // Tallenna nykyinen tila
    const currentMatrix = player.matrix;
    const currentPos = {...player.pos};
    const currentType = player.type;
    
    // Nollaa transformaatiot
    context.setTransform(1, 0, 0, 1, 0, 0);
    nextContext.setTransform(1, 0, 0, 1, 0, 0);
    
    if (window.innerWidth <= 350) {
        // Eritt√§in pienet n√§yt√∂t
        canvas.width = 180;
        canvas.height = 360;
        canvas.style.width = '180px';
        canvas.style.height = '360px';
        context.scale(18, 18); // 180/10 = 18
        
        // Pienempi next canvas
        nextCanvas.width = 120;
        nextCanvas.height = 120;
        nextContext.scale(20, 20); // 120/6 = 20
    } else if (window.innerWidth <= 768) {
        // Mobile
        canvas.width = 240;
        canvas.height = 480;
        canvas.style.width = '240px';
        canvas.style.height = '480px';
        context.scale(24, 24); // 240/10 = 24
        
        // Next canvas mobile
        nextCanvas.width = 150;
        nextCanvas.height = 150;
        nextContext.scale(25, 25); // 150/6 = 25
    } else {
        // Desktop: 300x600
        canvas.width = 300;
        canvas.height = 600;
        canvas.style.width = '300px';
        canvas.style.height = '600px';
        context.scale(30, 30); // 300/10 = 30
        
        // Next canvas: 200x200
        nextCanvas.width = 200;
        nextCanvas.height = 200;
        nextContext.scale(33, 33); // 200/6 = 33
    }
    
    // Palauta pelaajan tila
    player.matrix = currentMatrix;
    player.pos = currentPos;
    player.type = currentType;
    
    // // Piirr√§ next-pala heti
    if (nextPiece) {
        drawNextPiece();
    }
}

// Kutsu alustuksessa
adjustCanvasForMobile();

// Kuuntele ikkunan koon muutoksia

// Kaikki alustukset
initControls();
playerReset();
updateDisplay();
update();

// Simple Google Analytics tracking
window.addEventListener('load', () => {
    if (typeof gtag !== 'undefined') {
        gtag('event', 'page_view', {
            page_title: 'Tetris Game'
        });
    }
});
    </script>
</body>
</html>