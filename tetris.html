<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            margin: 0;
        }

        .game-container {
            display: flex;
            flex-direction: column; /* ← Muutettu pystysuoraan */
            gap: 15px; /* ← Pienempi gap */
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-width: 100vw;
            align-items: center; /* ← Keskitä kaikki */
        }

        .info-panels-row {
            display: flex;
            gap: 15px;
            order: 2; /* ← SCORE ja NEXT keskelle */
            width: 100%;
            max-width: 500px;
            justify-content: center;
        }

        #tetris {
            display: block;
            background: radial-gradient(circle at center, #001122 0%, #000000 100%);
            background-size: 100% 100%;
            border: 3px solid #0099ff;
            box-shadow: 
                inset 0 0 30px rgba(0,150,255,0.3),
                0 0 20px rgba(0,150,255,0.5);
            width: 300px;
            height: 600px;
            border-radius: 10px;
            touch-action: none;
            user-select: none;
            order: 3; /* ← Tetris alas */
        }

        /* SCORE & NEXT paneelit ylös */
        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            flex: 1;
            display: flex; /* ← Lisää flex */
            flex-direction: column; /* ← Pystysuora layout */
            align-items: center; /* ← Keskitä kaikki sisältö */
            text-align: center; /* ← Keskitä teksti */
        }

        .info-panel h2 {
            text-align: center;
            margin-bottom: 8px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            font-size: 14px;
            width: 100%; /* ← Vie koko leveys */
        }

        .score-display {
            font-size: 20px; /* ← Pienempi fontti (oli 24px) */
            font-weight: bold;
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .level-display {
            font-size: 14px; /* ← Pienempi fontti (oli 16px) */
            text-align: center;
            margin-top: 6px; /* ← Pienempi margin (oli 8px) */
            color: #ff6b6b;
        }

        .lines-display {
            font-size: 12px; /* ← Pienempi fontti (oli 14px) */
            text-align: center;
            margin-top: 4px; /* ← Pienempi margin (oli 5px) */
            color: #4ecdc4;
        }

        .next-piece {
            width: 100px; /* ← Pienempi leveys (oli 120px) */
            height: 100px; /* ← Pienempi korkeus (oli 120px) */
            background: #000;
            border: 2px solid #fff;
            border-radius: 8px; /* ← Pienempi radius (oli 10px) */
            display: block;
            image-rendering: pixelated;
            margin: 0; /* ← Ei marginaalia, flex hoitaa keskityksen */
        }

        /* CONTROLS alas molemmissa */
        .controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            font-size: 14px;
            transition: all 0.3s ease;
            cursor: pointer;
            overflow: hidden;
            order: 1; /* ← CONTROLS ylös */
            width: 100%;
            max-width: 400px; /* ← Maksimileveys */
        }

        .controls h3 {
            color: #ffd700;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
            transition: all 0.3s ease;
        }

        .controls-content {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .controls.expanded .controls-content {
            max-height: 400px;
            opacity: 1;
            margin-top: 15px;
        }

        .controls:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .controls.expanded {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 215, 0, 0.4);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .controls h3::after {
            content: " ▼";
            font-size: 14px;
            color: rgba(255, 215, 0, 0.7);
            transition: transform 0.3s ease;
        }

        .controls.expanded h3::after {
            transform: rotate(180deg);
        }

        .controls p {
            margin: 5px 0;
            font-size: 14px;
            color: #fff;
            display: block;
        }

        .controls::after {
            content: "";
            display: none;
        }

        .pause-btn {
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #333;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .pause-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 215, 0, 0.3);
        }

        .new-game-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .new-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(255, 107, 107, 0.3);
            background: linear-gradient(45deg, #ff5252, #e53935);
        }

        .new-game-btn:active {
            transform: translateY(0);
            box-shadow: 0 5px 10px rgba(255, 107, 107, 0.2);
        }

        .volume-control {
            margin-top: 15px;
        }

        .volume-slider {
            height: 4px;
            margin-top: 8px;
            width: 100%;
            accent-color: #ffd700;
        }

        .volume-label {
            font-size: 14px;
            color: rgba(255, 215, 0, 0.8);
            margin-bottom: 5px;
            display: block;
        }

        #volumeValue {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            border: 3px solid #ff4757;
            display: none;
            z-index: 1000;
            max-width: 90vw;
        }

        .game-over h2 {
            color: #ff4757;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .restart-btn {
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 210, 255, 0.3);
        }

        /* Takaisin-nappi */
        .back-button-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        .back-btn {
            display: inline-block;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffd700;
            text-decoration: none;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        /* Animaatiot */
        @keyframes lineComplete {
            0% { background-color: #fff; }
            50% { background-color: #ff0000; }
            100% { background-color: #fff; }
        }

        .line-flash {
            animation: lineComplete 0.3s ease-in-out 3;
        }

        @keyframes levelUp {
            0% { 
                transform: scale(1);
                color: #ff6b6b;
            }
            50% { 
                transform: scale(1.2);
                color: #ffd700;
                text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
            100% { 
                transform: scale(1);
                color: #ff6b6b;
            }
        }

        .level-up-animation {
            animation: levelUp 0.6s ease-in-out;
        }

        /* Mobile-optimointi */
        @media (max-width: 768px) {
            body {
                padding: 5px;
                padding-top: 50px;
                min-height: 100vh;
                overflow-x: hidden;
            }
            
            .game-container {
                flex-direction: column;
                gap: 10px;
                padding: 10px;
                align-items: center;
                width: 100%;
                max-width: 100vw;
                box-sizing: border-box;
            }
            
            .controls {
                order: 1; /* ← CONTROLS ylös */
                padding: 6px;
                font-size: 8px;
                border-radius: 6px;
                width: 240px;
                max-width: 240px;
            }
            
            .info-panels-row {
                gap: 8px;
                max-width: 240px;
                order: 2; /* ← SCORE ja NEXT keskelle */
            }
            
            #tetris {
                width: 240px !important;
                height: 480px !important;
                border: 2px solid #0099ff;
                border-radius: 8px;
                order: 3; /* ← Tetris alas */
            }
            
            /* Loput mobile-tyylit pysyvät samoina... */
            .info-panel {
                padding: 4px;
                border-radius: 4px;
            }
            
            .info-panel h2 {
                font-size: 9px;
                margin-bottom: 3px;
            }
            
            .score-display {
                font-size: 12px;
            }
            
            .level-display {
                font-size: 8px;
                margin-top: 1px;
            }
            
            .lines-display {
                font-size: 7px;
                margin-top: 1px;
            }
            
            .next-piece {
                width: 45px;
                height: 45px;
            }
            
            .controls h3 {
                font-size: 10px;
                margin-bottom: 0;
            }
            
            .controls p {
                font-size: 7px;
                margin: 1px 0;
            }
            
            .controls.expanded .controls-content {
                max-height: 150px;
                margin-top: 4px;
            }
            
            .pause-btn, .new-game-btn {
                padding: 4px 8px;
                font-size: 8px;
                margin-top: 4px;
            }
            
            .volume-control {
                margin-top: 4px;
            }
            
            .volume-label {
                font-size: 7px;
            }
            
            .volume-slider {
                height: 2px;
            }
            
            #volumeValue {
                font-size: 6px;
            }
            
            .controls::after {
                content: "📱 Tap to expand";
                font-size: 7px;
                color: rgba(255, 215, 0, 0.6);
                display: block;
                text-align: center;
                line-height: 1.1;
                margin-top: 3px;
            }
            
            .controls.expanded::after {
                display: none;
            }
            
            .back-button-container {
                top: 5px;
            }
            
            .back-btn {
                padding: 4px 8px;
                font-size: 10px;
                border-radius: 4px;
            }
            
            .game-over {
                padding: 15px;
                max-width: 80vw;
            }
            
            .game-over h2 {
                font-size: 20px;
                margin-bottom: 10px;
            }
            
            .restart-btn {
                padding: 8px 15px;
                font-size: 12px;
                margin-top: 10px;
            }
        }

        /* Erittäin pienet näytöt */
        @media (max-width: 420px) {
            .controls {
                width: 200px;
                max-width: 200px;
                order: 1; /* ← CONTROLS ylös */
            }
            
            .info-panels-row {
                max-width: 200px;
                order: 2; /* ← SCORE ja NEXT keskelle */
            }
            
            #tetris {
                width: 200px !important;
                height: 400px !important;
                order: 3; /* ← Tetris alas */
            }
        }

        /* Erittäin pienet näytöt (alle 350px) */
        @media (max-width: 350px) {
            .controls {
                max-width: 180px;
                width: 180px;
                order: 1; /* ← CONTROLS ylös */
            }
            
            .info-panels-row {
                max-width: 180px;
                order: 2; /* ← SCORE ja NEXT keskelle */
            }
            
            #tetris {
                width: 180px !important;
                height: 360px !important;
                order: 3; /* ← Tetris alas */
            }
        }
    </style>
</head>
<body>
    <!-- Takaisin-nappi -->
    <div class="back-button-container">
        <a href="index.html" class="back-btn">
            ⬅️ Back to Home
        </a>
    </div>

    <div class="game-container">
        <!-- 1. SCORE ja NEXT ylös -->
        <div class="info-panels-row">
            <div class="info-panel">
                <h2>SCORE</h2>
                <div class="score-display" id="score">0</div>
                <div class="level-display">Level: <span id="level">1</span></div>
                <div class="lines-display">Lines: <span id="lines">0</span></div>
            </div>

            <div class="info-panel">
                <h2>NEXT</h2>
                <canvas class="next-piece" id="nextPiece" width="120" height="120"></canvas>
            </div>
        </div>

        <!-- 2. TETRIS keskelle - POISTA .game-board wrapper! -->
        <canvas id="tetris" width="300" height="600"></canvas>
        
        <!-- 3. CONTROLS alas -->
        <div class="controls" id="controlsPanel">
            <h3>CONTROLS</h3>
            <div class="controls-content">
                <p>⬅️ A / ← - Left</p>
                <p>➡️ D / → - Right</p>
                <p>⬇️ S / ↓ - Down</p>
                <p>🔄 W / ↑ - Rotate</p>
                <p>⚡ Space - Drop</p>
                <p>⏸️ P - Pause</p>
                <p>🔄 Ctrl+R - New Game</p>
                <button class="pause-btn" id="pauseBtn">⏸️ PAUSE</button>
                <button class="new-game-btn" id="newGameBtn">🎮 NEW GAME</button>
                
                <div class="volume-control">
                    <label class="volume-label">🔊 Volume</label>
                    <input type="range" class="volume-slider" id="volumeSlider" 
                           min="0" max="100" value="50">
                    <span id="volumeValue">50%</span>
                </div>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOver">
        <h2>GAME OVER!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Level: <span id="finalLevel">1</span></p>
        <p>Lines: <span id="finalLines">0</span></p>
        <button class="restart-btn" onclick="startNewGame()">🎮 NEW GAME</button>
    </div>

    <script>
const canvas = document.getElementById('tetris');
const context = canvas.getContext('2d');
const nextCanvas = document.getElementById('nextPiece');
const nextContext = nextCanvas.getContext('2d');

// Pelin muuttujat
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
let score = 0;
let level = 1;
let lines = 0;
let isPaused = false;
let gameOver = false;
let soundVolume = 0.5;

// Touch/Mouse muuttujat
let isDragging = false;
let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;

// Tetris-palikat
const tetrominoes = {
    T: [
        [0, 1, 0],
        [1, 1, 1],
        [0, 0, 0]
    ],
    O: [
        [1, 1],
        [1, 1]
    ],
    L: [
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 0]
    ],
    J: [
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
    ],
    I: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
    ],
    S: [
        [0, 1, 1],
        [1, 1, 0],
        [0, 0, 0]
    ],
    Z: [
        [1, 1, 0],
        [0, 1, 1],
        [0, 0, 0]
    ]
};

// Värit
const colors = {
    T: '#a855f7',
    O: '#fbbf24',
    L: '#f97316',
    J: '#3b82f6',
    I: '#06b6d4',
    S: '#10b981',
    Z: '#ef4444'
};

// Pelialue
const arena = createMatrix(10, 20);

// Pelaajan pala
const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    type: null
};

let nextPiece = null;

// ÄÄNITEHOSTEET - KORJATTU VERSIO
let audioContext = null;
let audioInitialized = false;

function initAudio() {
    if (audioContext || soundVolume === 0) return;
    
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        audioInitialized = true;
        console.log('Audio initialized successfully');
    } catch (e) {
        console.log('Audio not supported:', e);
        audioInitialized = false;
    }
}

function resumeAudioContext() {
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
            console.log('Audio context resumed');
        }).catch(e => {
            console.log('Failed to resume audio context:', e);
        });
    }
}

function createBeep(frequency, duration, type = 'sine') {
    if (soundVolume === 0) return;
    
    // Alusta audio ensimmäisellä kerralla
    if (!audioContext) {
        initAudio();
    }
    
    if (!audioContext || !audioInitialized) return;
    
    try {
        // Varmista että context on käynnissä
        resumeAudioContext();
        
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
        oscillator.type = type;
        
        // Lyhyempi fade out, vähemmän eksponentiaalinen
        const volume = soundVolume * 0.1;
        gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration);
        
        // Siivoa muisti
        oscillator.onended = () => {
            try {
                oscillator.disconnect();
                gainNode.disconnect();
            } catch (e) {
                // Ei tee mitään jos jo disconnected
            }
        };
        
    } catch (e) {
        console.log('Audio creation failed:', e);
        // Yritä alustaa uudelleen seuraavalla kerralla
        audioContext = null;
        audioInitialized = false;
    }
}

// Ääni-funktiot pysyvät samoina
function playRotateSound() {
    createBeep(300, 0.15, 'sine');
}

function playMoveSound() {
    createBeep(200, 0.1, 'sine');
}

function playDropSound() {
    createBeep(120, 0.2, 'sine');
}

function playLineSound() {
    setTimeout(() => createBeep(262, 0.15, 'sine'), 0);
    setTimeout(() => createBeep(330, 0.15, 'sine'), 150);
    setTimeout(() => createBeep(392, 0.15, 'sine'), 300);
    setTimeout(() => createBeep(523, 0.25, 'sine'), 450);
}

function playTetrisSound() {
    setTimeout(() => createBeep(262, 0.12, 'sine'), 0);
    setTimeout(() => createBeep(330, 0.12, 'sine'), 120);
    setTimeout(() => createBeep(392, 0.12, 'sine'), 240);
    setTimeout(() => createBeep(523, 0.12, 'sine'), 360);
    setTimeout(() => createBeep(659, 0.12, 'sine'), 480);
    setTimeout(() => createBeep(784, 0.25, 'sine'), 600);
}

function playGameOverSound() {
    setTimeout(() => createBeep(392, 0.3, 'sine'), 0);
    setTimeout(() => createBeep(370, 0.3, 'sine'), 300);
    setTimeout(() => createBeep(349, 0.3, 'sine'), 600);
    setTimeout(() => createBeep(330, 0.3, 'sine'), 900);
    setTimeout(() => createBeep(294, 0.3, 'sine'), 1200);
    setTimeout(() => createBeep(262, 0.5, 'sine'), 1500);
}

function playLevelUpSound() {
    setTimeout(() => createBeep(262, 0.15, 'sine'), 0);
    setTimeout(() => createBeep(294, 0.15, 'sine'), 150);
    setTimeout(() => createBeep(330, 0.15, 'sine'), 300);
    setTimeout(() => createBeep(349, 0.15, 'sine'), 450);
    setTimeout(() => createBeep(392, 0.25, 'sine'), 600);
}

function createMatrix(w, h) {
    const matrix = [];
    while (h--) {
        matrix.push(new Array(w).fill(0));
    }
    return matrix;
}

function createPiece(type) {
    return tetrominoes[type];
}

function drawGrid() {
    // Määritä ruudukon koko dynaamisesti
    const gridWidth = canvas.width / context.getTransform().a; // a = scaleX
    const gridHeight = canvas.height / context.getTransform().d; // d = scaleY
    
    // Ohut ristikko
    context.strokeStyle = 'rgba(0, 100, 150, 0.4)';
    context.lineWidth = 0.02;
    
    // Pystyviivat
    for (let x = 0; x <= 10; x++) {
        context.beginPath();
        context.moveTo(x, 0);
        context.lineTo(x, 20);
        context.stroke();
    }
    
    // Vaakaviivat
    for (let y = 0; y <= 20; y++) {
        context.beginPath();
        context.moveTo(0, y);
        context.lineTo(10, y);
        context.stroke();
    }
    
    // Paksummat 5-ruudun viivat
    context.strokeStyle = 'rgba(0, 150, 255, 0.6)';
    context.lineWidth = 0.03;
    
    for (let y = 5; y <= 20; y += 5) {
        context.beginPath();
        context.moveTo(0, y);
        context.lineTo(10, y);
        context.stroke();
    }
    
    // Vaara-alue (alaosa)
    context.fillStyle = 'rgba(255, 0, 0, 0.05)';
    context.fillRect(0, 17, 10, 3);
}

function draw() {
    // Määritä canvas koko dynaamisesti
    const canvasWidth = canvas.width / context.getTransform().a;
    const canvasHeight = canvas.height / context.getTransform().d;
    
    if (gameOver && !player.matrix) {
        context.fillStyle = '#000';
        context.fillRect(0, 0, canvasWidth, canvasHeight);
        drawGrid();

        arena.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    context.fillStyle = value;
                    context.fillRect(x, y, 1, 1);
                    
                    context.strokeStyle = '#fff';
                    context.lineWidth = 0.05;
                    context.strokeRect(x, y, 1, 1);
                }
            });
        });
        return;
    }

    context.fillStyle = '#000';
    context.fillRect(0, 0, canvasWidth, canvasHeight);

    drawGrid();

    arena.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                context.fillStyle = value;
                context.fillRect(x, y, 1, 1);
                
                context.strokeStyle = '#fff';
                context.lineWidth = 0.05;
                context.strokeRect(x, y, 1, 1);
            }
        });
    });

    if (player.matrix && !gameOver) {
        player.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    const drawY = y + player.pos.y;
                    const drawX = x + player.pos.x;
                    
                    if (drawY >= 0 && drawY < 20 && drawX >= 0 && drawX < 10) {
                        context.fillStyle = colors[player.type];
                        context.fillRect(drawX, drawY, 1, 1);
                        
                        context.strokeStyle = '#fff';
                        context.lineWidth = 0.05;
                        context.strokeRect(drawX, drawY, 1, 1);
                    }
                }
            });
        });
    }

    if (!gameOver) {
        drawNextPiece();
    } else {
        // Tyhjennä next canvas game over -tilassa
        const nextCanvasSize = nextCanvas.width / nextContext.getTransform().a;
        nextContext.fillStyle = '#000';
        nextContext.fillRect(0, 0, nextCanvasSize, nextCanvasSize);
    }
}

function drawNextPiece() {
    // Tyhjennä next canvas oikein
    const scale = nextContext.getTransform().a;
    const canvasSize = 10; // Oletetaan 10x10 ruudukon koko
    
    nextContext.fillStyle = '#000';
    nextContext.fillRect(0, 0, canvasSize, canvasSize);
    
    if (nextPiece) {
        // Keskitä pala canvakseen
        const pieceWidth = nextPiece.matrix[0].length;
        const pieceHeight = nextPiece.matrix.length;
        
        const offset = {
            x: (canvasSize - pieceWidth) / 2,
            y: (canvasSize - pieceHeight) / 2
        };
        
        nextPiece.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    nextContext.fillStyle = colors[nextPiece.type];
                    nextContext.fillRect(x + offset.x, y + offset.y, 1, 1);
                    
                    nextContext.strokeStyle = '#fff';
                    nextContext.lineWidth = 0.05;
                    nextContext.strokeRect(x + offset.x, y + offset.y, 1, 1);
                }
            });
        });
    }
}

function merge(arena, player) {
    player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                const mergeY = y + player.pos.y;
                const mergeX = x + player.pos.x;
                
                // Tarkista että koordinaatit ovat alueen sisällä
                if (mergeY >= 0 && mergeY < arena.length && 
                    mergeX >= 0 && mergeX < arena[0].length) {
                    arena[mergeY][mergeX] = colors[player.type];
                }
            }
        });
    });
}

function rotate(matrix, dir = 1) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }

    if (dir > 0) {
        matrix.forEach(row => row.reverse());
    } else {
        matrix.reverse();
    }
}

function collide(arena, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0) {
                if (y + o.y >= 0) {
                    if (y + o.y >= arena.length || 
                        x + o.x < 0 || 
                        x + o.x >= arena[0].length || 
                        arena[y + o.y][x + o.x] !== 0) {
                    return true;
                }
                } else {
                    if (x + o.x < 0 || x + o.x >= arena[0].length) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

function arenaSweep() {
    let linesCleared = 0;
    
    for (let y = arena.length - 1; y >= 0; --y) {
        let fullLine = true;
        
        for (let x = 0; x < arena[y].length; ++x) {
            if (arena[y][x] === 0) {
                fullLine = false;
                break;
            }
        }
        
        if (fullLine) {
            arena.splice(y, 1);
            arena.unshift(new Array(10).fill(0));
            linesCleared++;
            y++;
        }
    }

    if (linesCleared > 0) {
        if (linesCleared === 4) {
            playTetrisSound();
        } else {
            playLineSound();
        }

        const pointValues = [0, 40, 100, 300, 1200];
        const oldLevel = level;
        score += pointValues[linesCleared] * level;
        lines += linesCleared;
        
        level = Math.floor(lines / 10) + 1;
        
        if (level > oldLevel) {
            setTimeout(() => {
                playLevelUpSound();
                const levelElement = document.getElementById('level').parentElement;
                levelElement.classList.add('level-up-animation');
                setTimeout(() => {
                    levelElement.classList.remove('level-up-animation');
                }, 600);
            }, 500);
        }
        
        dropInterval = Math.max(50, 1000 - (level - 1) * 50);
        updateDisplay();
    }
}

function playerDrop() {
    if (gameOver) return;
    
    player.pos.y++;
    if (collide(arena, player)) {
        player.pos.y--;
        playDropSound();
        merge(arena, player);
        playerReset();
        arenaSweep();
    }
    dropCounter = 0;
}

function playerMove(dir) {
    if (gameOver) return;
    
    player.pos.x += dir;
    if (collide(arena, player)) {
        player.pos.x -= dir;
    } else {
        playMoveSound();
    }
}

function playerReset() {
    if (gameOver) return;
    
    if (nextPiece) {
        player.matrix = JSON.parse(JSON.stringify(nextPiece.matrix));
        player.type = nextPiece.type;
    } else {
        const pieces = 'TLOJISZ';
        const type = pieces[Math.floor(Math.random() * pieces.length)];
        player.matrix = JSON.parse(JSON.stringify(createPiece(type)));
        player.type = type;
    }
    
    const pieces = 'TLOJISZ';
    const nextType = pieces[Math.floor(Math.random() * pieces.length)];
    nextPiece = {
        matrix: JSON.parse(JSON.stringify(createPiece(nextType))),
        type: nextType
    };

    player.pos.y = -1;
    player.pos.x = Math.floor((arena[0].length - player.matrix[0].length) / 2);
    
    if (collide(arena, player)) {
        endGame();
        return;
    }
}

function playerRotate(dir) {
    if (gameOver) return;
    
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
            rotate(player.matrix, -dir);
            player.pos.x = pos;
            return;
        }
    }
    playRotateSound();
}

function hardDrop() {
    if (gameOver) return;
    
    while (!collide(arena, player)) {
        player.pos.y++;
        score += 1;
    }
    player.pos.y--;
    createBeep(100, 0.3, 'sine');
    merge(arena, player);
    playerReset();
    arenaSweep();
    updateDisplay();
}

function updateDisplay() {
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = lines;
}

function endGame() {
    gameOver = true;
    playGameOverSound();
    
    player.matrix = null;
    player.type = null;
    
    document.getElementById('finalScore').textContent = score;
    document.getElementById('finalLevel').textContent = level;
    document.getElementById('finalLines').textContent = lines;
    document.getElementById('gameOver').style.display = 'block';
}

function startNewGame() {
    const confirmRestart = gameOver || confirm('Do you really want to start a new game?');
    
    if (!confirmRestart) return;

    gameOver = true;
    
    arena.forEach(row => row.fill(0));
    score = 0;
    level = 1;
    lines = 0;
    dropInterval = 1000;
    dropCounter = 0;
    lastTime = 0;
    isPaused = false;
    
    player.matrix = null;
    player.type = null;
    player.pos = {x: 0, y: 0};
    nextPiece = null;
    
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('pauseBtn').textContent = '⏸️ PAUSE';
    
    gameOver = false;
    playerReset();
    updateDisplay();
    update();
}

function togglePause() {
    if (gameOver) return;
    
    isPaused = !isPaused;
    const btn = document.getElementById('pauseBtn');
    btn.textContent = isPaused ? '▶️ RESUME' : '⏸️ PAUSE';
}

function update(time = 0) {
    if (gameOver) return;
    
    if (!isPaused) {
        const deltaTime = time - lastTime;
        dropCounter += deltaTime;
        
        if (dropCounter > dropInterval) {
            playerDrop();
        }
    }
    
    lastTime = time;
    draw();
    
    if (!gameOver) {
        requestAnimationFrame(update);
    }
}

// CONTROLS-panelin laajennus
const controlsPanel = document.getElementById('controlsPanel');
let controlsExpanded = false;

controlsPanel.addEventListener('click', (e) => {
    // Älä laajenna jos klikkaat nappeja
    if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
        return;
    }
    
    controlsExpanded = !controlsExpanded;
    
    if (controlsExpanded) {
        controlsPanel.classList.add('expanded');
    } else {
        controlsPanel.classList.remove('expanded');
    }
});

// Estä laajennus/kutistus kun interaktoidaan controlsien kanssa
const controlsContent = document.querySelector('.controls-content');
controlsContent.addEventListener('click', (e) => {
    e.stopPropagation(); // Estä klikkauksen kulkeutuminen ylöspäin
});

// TOUCH & MOUSE KONTROLLIT
function initControls() {
    const canvas = document.getElementById('tetris');
    
    // Touch/Mouse muuttujat toistoa varten
    let touchRepeatInterval = null;
    let touchDirection = null;
    let isLongPress = false;
    
    // CSS hiirelle
    canvas.style.cursor = 'grab';
    canvas.style.transition = 'transform 0.1s ease';
    
    // Alusta audio ensimmäisen käyttäjävuorovaikutuksen yhteydessä
    const initAudioOnInteraction = () => {
        if (!audioInitialized) {
            initAudio();
            setTimeout(() => {
                if (soundVolume > 0) {
                    createBeep(200, 0.1, 'sine');
                }
            }, 100);
        }
    };
    
    // Touch events
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        initAudioOnInteraction();
        
        if (gameOver || isPaused) return;
        
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        touchStartX = touch.clientX - rect.left;
        touchStartY = touch.clientY - rect.top;
        touchStartTime = Date.now();
        isLongPress = false;
        
        // Aloita long press timer
        setTimeout(() => {
            if (touchStartTime > 0) { // Vielä kosketetaan
                isLongPress = true;
            }
        }, 200);
    }, { passive: false });
    
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (gameOver || isPaused || !isLongPress) return;
        
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const currentX = touch.clientX - rect.left;
        const currentY = touch.clientY - rect.top;
        const deltaX = currentX - touchStartX;
        const deltaY = currentY - touchStartY;
        
        // Päivitä aloituspiste kun suunta vaihtuu (sujuvampi liike)
        let shouldUpdateStartPos = false;
        
        // Määritä suunta ja aloita/vaihda toisto
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 20) {
            const newDirection = deltaX > 0 ? 'right' : 'left';
            if (touchDirection !== newDirection) {
                touchDirection = newDirection;
                shouldUpdateStartPos = true;
                // Pysäytä vanha toisto ja aloita uusi
                if (touchRepeatInterval) clearInterval(touchRepeatInterval);
                
                // Tee ensimmäinen liike heti
                if (touchStartTime > 0 && !gameOver && !isPaused) {
                    playerMove(touchDirection === 'right' ? 1 : -1);
                }
                
                touchRepeatInterval = setInterval(() => {
                    if (touchStartTime > 0 && !gameOver && !isPaused) {
                        playerMove(touchDirection === 'right' ? 1 : -1);
                    }
                }, 100); // 100ms toisto
            }
        } else if (deltaY > 30) {
            if (touchDirection !== 'down') {
                touchDirection = 'down';
                shouldUpdateStartPos = true;
                // Pysäytä vanha toisto ja aloita uusi
                if (touchRepeatInterval) clearInterval(touchRepeatInterval);
                
                // Tee ensimmäinen liike heti
                if (touchStartTime > 0 && !gameOver && !isPaused) {
                    playerDrop();
                }
                
                touchRepeatInterval = setInterval(() => {
                    if (touchStartTime > 0 && !gameOver && !isPaused) {
                        playerDrop();
                    }
                }, 80); // 80ms toisto alaspäin
            }
        }
        
        // Päivitä aloituspiste sulavampaa liikettä varten
        if (shouldUpdateStartPos) {
            touchStartX = currentX;
            touchStartY = currentY;
        }
    }, { passive: false });
    
    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        
        // Pysäytä toisto
        if (touchRepeatInterval) {
            clearInterval(touchRepeatInterval);
            touchRepeatInterval = null;
        }
        touchDirection = null;
        
        if (gameOver || isPaused) {
            touchStartTime = 0;
            return;
        }
        
        const touchDuration = Date.now() - touchStartTime;
        touchStartTime = 0;
        
        if (!isLongPress) {
            // Lyhyt kosketus - normaalit liikkeet
            const touch = e.changedTouches[0];
            const rect = canvas.getBoundingClientRect();
            
            const endX = touch.clientX - rect.left;
            const endY = touch.clientY - rect.top;
            const deltaX = endX - touchStartX;
            const deltaY = endY - touchStartY;
            
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                playerMove(deltaX > 0 ? 1 : -1);
            } else if (deltaY > 40) {
                playerDrop();
            } else if (touchDuration < 300 && Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20) {
                playerRotate(1);
            } else if (touchDuration > 600) {
                hardDrop();
            }
        }
    }, { passive: false });
    
    // Mouse events
    canvas.addEventListener('mousedown', (e) => {
        e.preventDefault();
        initAudioOnInteraction();
        
        if (gameOver || isPaused) return;
        
        const rect = canvas.getBoundingClientRect();
        touchStartX = e.clientX - rect.left;
        touchStartY = e.clientY - rect.top;
        touchStartTime = Date.now();
        isDragging = true;
        isLongPress = false;
        canvas.style.cursor = 'grabbing';
        
        // Aloita long press timer hiirelle
        setTimeout(() => {
            if (isDragging && touchStartTime > 0) {
                isLongPress = true;
            }
        }, 200);
    });
    
    canvas.addEventListener('mousemove', (e) => {
        e.preventDefault();
        if (!isDragging || gameOver || isPaused || !isLongPress) return;
        
        const rect = canvas.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        const deltaX = currentX - touchStartX;
        const deltaY = currentY - touchStartY;
        
        // Määritä suunta ja aloita/vaihda toisto hiirelle
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 15) {
            const newDirection = deltaX > 0 ? 'right' : 'left';
            if (touchDirection !== newDirection) {
                touchDirection = newDirection;
                // Pysäytä vanha toisto ja aloita uusi
                if (touchRepeatInterval) clearInterval(touchRepeatInterval);
                
                // Tee ensimmäinen liike heti
                if (isDragging && !gameOver && !isPaused) {
                    playerMove(touchDirection === 'right' ? 1 : -1);
                }
                
                touchRepeatInterval = setInterval(() => {
                    if (isDragging && !gameOver && !isPaused) {
                        playerMove(touchDirection === 'right' ? 1 : -1);
                    }
                }, 90); // 90ms toisto hiirelle
            }
        } else if (deltaY > 20) {
            if (touchDirection !== 'down') {
                touchDirection = 'down';
                // Pysäytä vanha toisto ja aloita uusi
                if (touchRepeatInterval) clearInterval(touchRepeatInterval);
                
                // Tee ensimmäinen liike heti
                if (isDragging && !gameOver && !isPaused) {
                    playerDrop();
                }
                
                touchRepeatInterval = setInterval(() => {
                    if (isDragging && !gameOver && !isPaused) {
                        playerDrop();
                    }
                }, 70); // 70ms toisto alaspäin hiirelle
            }
        }
    });
    
    canvas.addEventListener('mouseup', (e) => {
        e.preventDefault();
        
        // Pysäytä toisto
        if (touchRepeatInterval) {
            clearInterval(touchRepeatInterval);
            touchRepeatInterval = null;
        }
        touchDirection = null;
        
        if (!isDragging) return;
        
        isDragging = false;
        canvas.style.cursor = 'grab';
        
        if (gameOver || isPaused) {
            touchStartTime = 0;
            return;
        }
        
        const mouseDuration = Date.now() - touchStartTime;
        touchStartTime = 0;
        
        if (!isLongPress) {
            // Lyhyt klikkaus - normaalit liikkeet
            const rect = canvas.getBoundingClientRect();
            const endX = e.clientX - rect.left;
            const endY = e.clientY - rect.top;
            const deltaX = endX - touchStartX;
            const deltaY = endY - touchStartY;
            
            if (e.button === 2) {
                hardDrop();
                return;
            }
            
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 20) {
                playerMove(deltaX > 0 ? 1 : -1);
            } else if (deltaY > 15) {
                playerDrop();
            } else if (mouseDuration < 300 && Math.abs(deltaX) < 15 && Math.abs(deltaY) < 15) {
                playerRotate(1);
            } else if (mouseDuration > 500) {
                hardDrop();
            }
        }
    });
    
    canvas.addEventListener('mouseleave', () => {
        // Pysäytä toisto kun hiiri poistuu
        if (touchRepeatInterval) {
            clearInterval(touchRepeatInterval);
            touchRepeatInterval = null;
        }
        touchDirection = null;
        isDragging = false;
        isLongPress = false;
        touchStartTime = 0;
        canvas.style.cursor = 'grab';
    });
    
    // Scroll wheel
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        if (gameOver || isPaused) return;
        
        if (e.deltaY < 0) {
            playerRotate(1);
        } else {
            playerDrop();
        }
    }, { passive: false });
    
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
}

// Keyboard controls
document.addEventListener('keydown', event => {
    // Alusta audio ensimmäisen näppäimen painalluksen yhteydessä
    if (!audioInitialized && soundVolume > 0) {
        initAudio();
    }
    
    if (event.code === 'KeyR' && (event.ctrlKey || event.metaKey)) {
        event.preventDefault();
        startNewGame();
        return;
    }
    
    if (gameOver) return;
    if (isPaused && event.code !== 'KeyP') return;
    
    switch(event.code) {
        case 'ArrowLeft':
        case 'KeyA':
            event.preventDefault();
            playerMove(-1);
            break;
        case 'ArrowRight':
        case 'KeyD':
            event.preventDefault();
            playerMove(1);
            break;
        case 'ArrowDown':
        case 'KeyS':
            event.preventDefault();
            playerDrop();
            break;
        case 'ArrowUp':
        case 'KeyW':
            event.preventDefault();
            playerRotate(1);
            break;
        case 'Space':
            event.preventDefault();
            hardDrop();
            break;
        case 'KeyP':
            event.preventDefault();
            togglePause();
            break;
    }
});

// Volume control
const volumeSlider = document.getElementById('volumeSlider');
const volumeValue = document.getElementById('volumeValue');

volumeSlider.addEventListener('input', (e) => {
    soundVolume = e.target.value / 100;
    volumeValue.textContent = e.target.value + '%';
});

// Event listeners
document.getElementById('pauseBtn').addEventListener('click', togglePause);
document.getElementById('newGameBtn').addEventListener('click', startNewGame);

// Dynaaminen canvas-skaalaus mobiilille
function adjustCanvasForMobile() {
    // Tallenna nykyinen tila
    const currentMatrix = player.matrix;
    const currentPos = {...player.pos};
    const currentType = player.type;
    
    // Nollaa transformaatiot
    context.setTransform(1, 0, 0, 1, 0, 0);
    nextContext.setTransform(1, 0, 0, 1, 0, 0);
    
    if (window.innerWidth <= 350) {
        // Erittäin pienet näytöt: 180x360
        canvas.width = 180;
        canvas.height = 360;
        canvas.style.width = '180px';
        canvas.style.height = '360px';
        context.scale(18, 18); // 180/10 = 18
        
        // Next canvas: 30x30 CSS → 60x60 canvas
        nextCanvas.width = 60;
        nextCanvas.height = 60;
        nextContext.scale(6, 6); // 60/10 = 6
        
    } else if (window.innerWidth <= 420) {
        // Pienet näytöt: 200x400
        canvas.width = 200;
        canvas.height = 400;
        canvas.style.width = '200px';
        canvas.style.height = '400px';
        context.scale(20, 20); // 200/10 = 20
        
        // Next canvas: 35x35 CSS → 70x70 canvas
        nextCanvas.width = 70;
        nextCanvas.height = 70;
        nextContext.scale(7, 7); // 70/10 = 7
        
    } else if (window.innerWidth <= 768) {
        // Tavalliset mobiili: 240x480  
        canvas.width = 240;
        canvas.height = 480;
        canvas.style.width = '240px';
        canvas.style.height = '480px';
        context.scale(24, 24); // 240/10 = 24
        
        // Next canvas: 45x45 CSS → 90x90 canvas
        nextCanvas.width = 90;
        nextCanvas.height = 90;
        nextContext.scale(9, 9); // 90/10 = 9
        
    } else {
        // Desktop: 300x600
        canvas.width = 300;
        canvas.height = 600;
        canvas.style.width = '300px';
        canvas.style.height = '600px';
        context.scale(30, 30); // 300/10 = 30
        
        // Next canvas: 100x100 CSS → 200x200 canvas
        nextCanvas.width = 200;
        nextCanvas.height = 200;
        nextContext.scale(20, 20); // 200/10 = 20
    }
    
    // Palauta pelaajan tila
    player.matrix = currentMatrix;
    player.pos = currentPos;
    player.type = currentType;
    
    // Piirrä next-pala heti
    if (nextPiece) {
        drawNextPiece();
    }
}

// Kutsu alustuksessa
adjustCanvasForMobile();

// Kuuntele ikkunan koon muutoksia

// Kaikki alustukset
initControls();
playerReset();
updateDisplay();
update();
    </script>
</body>
</html>